\documentclass[11]{Report}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{float}
\usepackage{algpseudocode}
\makeatletter
\newcommand*\bigcdot{\mathpalette\bigcdot@{.4}}
\newcommand*\bigcdot@[2]{\mathbin{\vcenter{\hbox{\scalebox{#2}{$\m@th#1\bullet$}}}}}
\makeatother
\usepackage{siunitx} % Required for alignment
\usepackage{titlesec}

\sisetup{
  round-mode          = places, % Rounds numbers
  round-precision     = 2, % to 2 places
}

\begin{document}

\author{Derek W. Harrison}
\title{An implementation of the Gauss-Jordan method}

\maketitle
\section*{Introduction}
The Gauss-Jordan method is implemented with row sorting instead of row swapping to compute the inverse of a matrix in $O \left( n^3 \right) $ time. The pseudocode of the method is given in the next section. The procedure GAUSS-JORDAN($A$, $n$, $C$) performs the inversion and takes as input a square matrix $A$ and the size of the input matrix $n$ and stores the inverse of $A$ in $C$. The procedure assumes the input matrix is non-singular. Merge sort is used to sort the rows of the matrices according to the number of leading zeros. It is the underlying algorithm of the SORT-MAT($M$, $n$, $C$) procedure used to sort the matrices. 

\clearpage

\section*{Algorithm}
\begin{algorithmic}
\Function{gauss-jordan}{$A$, $n$, $C$} 

\Call{init-mat}{$C$, $n$}

let $M[0..n - 1]$ be a new array

\State //Convert to row echelon form
\For{$c = 0$; $c < n$; $c = c + 1$}

\If {$A[c][c] == 0$}
	\State \Call{get-order}{$A$, $n$, $M$}
	\State \Call{sort-mat}{$M$, $n$, $A$}
	\State \Call{sort-mat}{$M$, $n$, $C$}
\EndIf

\State //Normalize rows
\For{$j = c + 1$; $j < n$; $j = j + 1$}
	\State $A[c][j] = A[c][j] / A[c][c]$
\EndFor

\For{$j = 0$; $j < n$; $j = j + 1$}
	\State $C[c][j] = C[c][j] / A[c][c]$
\EndFor

\State $A[c][c] = 1.0$

\State //Delete elements in rows below

\For{$r = c + 1$; $r < n$; $r = r + 1$}
\If {$A[r][c] \neq 0$}
	\For{$j = c + 1$; $j < n$; $j = j + 1$}
	    \State $A[r][j] = -A[r][c] \cdot A[c][j] + A[r][j]$
	\EndFor
	\For{$j = 0$; $j < n$; $j = j + 1$}
	    \State $C[r][j] = -A[r][c] \cdot C[c][j] + C[r][j]$
	\EndFor
	
	\State $A[r][c] = 0$
\EndIf
\EndFor
            
\EndFor

\State //Backtrack to convert to reduced row echelon form

\For{$c = n - 1$; $c > 0$; $c = c - 1$}
	\For{$r = c - 1$; $r > -1$; $r = r - 1$}
		\If{$A[r][c] \neq 0$}
			\For{$j = 0$; $j < n$; $j = j + 1$}
				\State $C[r][j] = -A[r][c] \cdot C[c][j] + C[r][j]$
			\EndFor
			
			\State $A[r][c] = 0$
		\EndIf
	\EndFor
\EndFor

\EndFunction

\end{algorithmic}

\begin{algorithmic}
\Function{init-mat}{$A$, $n$} 
   \For{$i = 0$; $i < n$; $i = i + 1$}
	\For{$j = 0$; $j < n$; $j = j + 1$}
		\If{$i == j$}
			\State $A[i][j] = 1$
		\Else
		    \State $A[i][j] = 0$
		\EndIf
	\EndFor
\EndFor
\EndFunction
\end{algorithmic}

\section*{}

\begin{algorithmic}
\Function{get-order}{$A$, $n$, $M$} 
    
   \For{$i = 0$; $i < n$; $i = i + 1$}
   		\State c = 0
		\While{$A[i][c] == 0$ and $c < n$} 
			\State $c = c + 1$  
		\EndWhile
		\State $M[i].key = c$
		\State $M[i].prev = i$
	\EndFor

\EndFunction
\end{algorithmic}

\section*{}

\begin{algorithmic}
\Function{sort-mat}{$M$, $n$, $A$} 

Sort rows in $A$ according to the keys of elements in $M$ using merge-sort.

\EndFunction
\end{algorithmic}

\end{document}